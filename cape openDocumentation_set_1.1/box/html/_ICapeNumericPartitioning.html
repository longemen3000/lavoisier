<!-- Generated by Sandia idldoc -->
<html><head>
<title> Interface ICapeNumericPartitioning
</title></head>
<a name=__Top__></a><a name=ICapeNumericPartitioning>
<H1>Interface ICapeNumericPartitioning</H1></a>
<pre><a href=..\\idl\\ICapeNumericSMST.idl>IDL source</a>    <a href=index.html>Global index</a><hr></pre>
interface <b>ICapeNumericPartitioning</b> : <a href=_ICapeNumericAnalysis.html#ICapeNumericAnalysis>ICapeNumericAnalysis</a>
<p>

<p><tt>Performs a Partitioning and Ordering Analysis on a Flowsheet.</tt></p>
<ul>
<li><i>File</i> = ICapeNumericSMST.idl
<li><i>Date</i> = June 99
<li><i>Project</i> = CAPE-OPEN BE 3512
</ul>        
<dl>
  <dt> <b>Author:</b>
  <dd>  CAPE-OPEN Partners
</dl>
<dl>
  <dt> <b>See Also:</b>
  <dd> <a  href="http://www.cape-open.org"> CAPE-OPEN Web Site </a>, <a  href="mailto:jeanpierre.belaud@ensigct.fr">Jean-Pierre Belaud</a>, Inherited  operations from ICapeNumericAnalysis
  
</dl>

<p>

<hr>
<h1>
  <img src="operation_index.gif" alt="Operation index."> 
</h1><dl>
<dt><b><li><a href=_ICapeNumericPartitioning.html#ICapeNumericPartitioning::CreateAndCompletePartitionGraph>CreateAndCompletePartitionGraph</a></b>
<dd> 
<p>Creates and complete an ICapeNumericPartitionGraph interface from a specified partition. The return value is 
in accordance with the last calculation of partitioning analysis.<br>
The intermediate streams between partitions become either FEED or PRODUCT streams of the built Partition Graph.<br>
This generated ICapeNumericPartitionGraph is created from the flowsheet factory and is called name.<br>
partitionNb belongs to the interval [1..partition count].</p>
<p><i>Pre Conditions</i>: A ICapeNumericFlowsheetFactory exists.<br>
Use ICapeNumericPartitioning::GetPartitionCount() method in order to have the number of partitions.<br>
The Perform() method is terminated successfully.</p>
<p><i>Post Conditions</i>: The generated ICapeNumericPartitionGraph can be used directly as a flowsheet into
the tearing analysis.<br>
Assures to generate a consistent flowsheet for the computation of a tearing analysis.</p>

<dt><b><li><a href=_ICapeNumericPartitioning.html#ICapeNumericPartitioning::GetExternalSystemId>GetExternalSystemId</a></b>
<dd> 
<p>Sets the external system.</p>
<p><i>Pre Conditions</i>: Returns the value set by the SetExternalSystemId() method, otherwise the returned 
value is an implementation dependent default value.</p>
<p><i>Post Conditions</i>: None.</p>

<dt><b><li><a href=_ICapeNumericPartitioning.html#ICapeNumericPartitioning::GetPartitionCount>GetPartitionCount</a></b>
<dd> 
<p>Gets the number of partitions resulting from the last successful computation (with the ICapeNumericAnalysis::Perform() method).</p>
<p><i>Pre Conditions</i>: None.</p>
<p><i>Post Conditions</i>: None.</p>

<dt><b><li><a href=_ICapeNumericPartitioning.html#ICapeNumericPartitioning::GetUnitsInPartition>GetUnitsInPartition</a></b>
<dd> 
<p>Gets the list of units for a specified partition resulting from the last successful computation (with the ICapeNumericAnalysis::Perform() method).<br>
partitionNb belongs to the interval [1..partition count].<br>
The order of partitions corresponds to the partition computation list (ordering) e.g. 
where partitionNb=1, it indicates the first partition to be computed, where partitionNb=2, it designates the second partition to be computed, and so on ...<br>
The order of units is implementation dependent.</p>
<p><i>Pre Conditions</i>: Uses ICapeNumericPartitioning::GetPartitionCount method in order to have the number  of partitions.</p>
<p><i>Post Conditions</i>: None.</p>

<dt><b><li><a href=_ICapeNumericPartitioning.html#ICapeNumericPartitioning::SetExternalSystemId>SetExternalSystemId</a></b>
<dd> 
<p>Sets the external system.</p>
<p><i>Pre Conditions</i>: None.</p>
<p><i>Post Conditions</i>: The unitId value will be used by CreateAndCompletePartitionGraph() method in 
order to characterise the FEED and PRODUCT streams.</p>

</dl>
<h1>
  <img src="operations.gif" alt="Operations."> 
</h1><li><h3><a name=ICapeNumericPartitioning::CreateAndCompletePartitionGraph>CreateAndCompletePartitionGraph</a></h3>
<pre>
  <a href=_ICapeNumericPartitionGraph.html#ICapeNumericPartitionGraph>ICapeNumericPartitionGraph</a> <b>CreateAndCompletePartitionGraph</b>(in <a href=_CapeLong.html#CapeLong>CapeLong</a> partitionNb,
      in <a href=_CapeString.html#CapeString>CapeString</a> name,
      in <a href=_ICapeNumericFlowsheetFactory.html#ICapeNumericFlowsheetFactory>ICapeNumericFlowsheetFactory</a> factory)
    raises(<a href=_CapeBAD_INV_ORDER.html#CapeBAD_INV_ORDER>CapeBAD_INV_ORDER</a>, <a href=_CapeBAD_PARAM.html#CapeBAD_PARAM>CapeBAD_PARAM</a>, <a href=_CapeIMP_LIMIT.html#CapeIMP_LIMIT>CapeIMP_LIMIT</a>, <a href=_CapeNO_IMPLEMENT.html#CapeNO_IMPLEMENT>CapeNO_IMPLEMENT</a>, <a href=_CapeNO_CONVERGE.html#CapeNO_CONVERGE>CapeNO_CONVERGE</a>, <a href=_CapeUNKNOWN.html#CapeUNKNOWN>CapeUNKNOWN</a>);</pre><dl>
  <dd>  
<p>Creates and complete an ICapeNumericPartitionGraph interface from a specified partition. The return value is 
in accordance with the last calculation of partitioning analysis.<br>
The intermediate streams between partitions become either FEED or PRODUCT streams of the built Partition Graph.<br>
This generated ICapeNumericPartitionGraph is created from the flowsheet factory and is called name.<br>
partitionNb belongs to the interval [1..partition count].</p>
<p><i>Pre Conditions</i>: A ICapeNumericFlowsheetFactory exists.<br>
Use ICapeNumericPartitioning::GetPartitionCount() method in order to have the number of partitions.<br>
The Perform() method is terminated successfully.</p>
<p><i>Post Conditions</i>: The generated ICapeNumericPartitionGraph can be used directly as a flowsheet into
the tearing analysis.<br>
Assures to generate a consistent flowsheet for the computation of a tearing analysis.</p>
<dl>
  <dt> <b>Returns:</b>
  <dd>  The object reference of ICapeNumericPartitionGraph interface.
</dl>
<dl>
  <dt> <b>Parameters:</b>
  <dd>  partitionNb: The rank of the partition.
  <dd>  name: The name of the partition to be generated.
  <dd>  factory: The factory which manages the partition to be generated.
</dl>
<dl>
  <dt> <b>Raises:</b>
  <dd> CapeBAD_INV_ORDER,  CapeBAD_PARAM, CapeIMP_LIMIT, CapeNO_IMPLEMENT, CapeNO_CONVERGE, CapeUNKNOWN
</dl>
<dl>
  <dt> <b>See Also:</b>
  <dd> <a href=_ICapeNumericAnalysis.html#ICapeNumericAnalysis::Perform>ICapeNumericAnalysis::Perform</a> , <a href=_ICapeNumericPartitioning.html#ICapeNumericPartitioning::GetPartitionCount>GetPartitionCount</a> , <a href=_ICapeNumericTearing.html#ICapeNumericTearing>ICapeNumericTearing</a> 
	  
</dl>

</dl>

<p>
<li><h3><a name=ICapeNumericPartitioning::GetExternalSystemId>GetExternalSystemId</a></h3>
<pre>
  <a href=_CapeLong.html#CapeLong>CapeLong</a> <b>GetExternalSystemId</b>()
    raises(<a href=_CapeUNKNOWN.html#CapeUNKNOWN>CapeUNKNOWN</a>);</pre><dl>
  <dd>  
<p>Sets the external system.</p>
<p><i>Pre Conditions</i>: Returns the value set by the SetExternalSystemId() method, otherwise the returned 
value is an implementation dependent default value.</p>
<p><i>Post Conditions</i>: None.</p>
<dl>
  <dt> <b>Returns:</b>
  <dd>  The unit identifier for the external system.
</dl>
<dl>
  <dt> <b>Raises:</b>
  <dd> <a href=_CapeUNKNOWN.html#CapeUNKNOWN>CapeUNKNOWN</a> 
</dl>
<dl>
  <dt> <b>See Also:</b>
  <dd> <a href=_ICapeNumericPartitioning.html#ICapeNumericPartitioning::SetExternalSystemId>SetExternalSystemId</a> 
	  
</dl>

</dl>

<p>
<li><h3><a name=ICapeNumericPartitioning::GetPartitionCount>GetPartitionCount</a></h3>
<pre>
  <a href=_CapeLong.html#CapeLong>CapeLong</a> <b>GetPartitionCount</b>()
    raises(<a href=_CapeBAD_INV_ORDER.html#CapeBAD_INV_ORDER>CapeBAD_INV_ORDER</a>, <a href=_CapeUNKNOWN.html#CapeUNKNOWN>CapeUNKNOWN</a>);</pre><dl>
  <dd>  
<p>Gets the number of partitions resulting from the last successful computation (with the ICapeNumericAnalysis::Perform() method).</p>
<p><i>Pre Conditions</i>: None.</p>
<p><i>Post Conditions</i>: None.</p>
<dl>
  <dt> <b>Returns:</b>
  <dd>  The number of partitions.
</dl>
<dl>
  <dt> <b>Raises:</b>
  <dd> CapeBAD_INV_ORDER,  CapeUNKNOWN
</dl>
<dl>
  <dt> <b>See Also:</b>
  <dd> <a href=_ICapeNumericAnalysis.html#ICapeNumericAnalysis::Perform>ICapeNumericAnalysis::Perform</a> 
	  
</dl>

</dl>

<p>
<li><h3><a name=ICapeNumericPartitioning::GetUnitsInPartition>GetUnitsInPartition</a></h3>
<pre>
  <a href=_CapeLongSequence.html#CapeLongSequence>CapeLongSequence</a> <b>GetUnitsInPartition</b>(in <a href=_CapeLong.html#CapeLong>CapeLong</a> partitionNb)
    raises(<a href=_CapeBAD_INV_ORDER.html#CapeBAD_INV_ORDER>CapeBAD_INV_ORDER</a>, <a href=_CapeBAD_PARAM.html#CapeBAD_PARAM>CapeBAD_PARAM</a>, <a href=_CapeUNKNOWN.html#CapeUNKNOWN>CapeUNKNOWN</a>);</pre><dl>
  <dd>  
<p>Gets the list of units for a specified partition resulting from the last successful computation (with the ICapeNumericAnalysis::Perform() method).<br>
partitionNb belongs to the interval [1..partition count].<br>
The order of partitions corresponds to the partition computation list (ordering) e.g. 
where partitionNb=1, it indicates the first partition to be computed, where partitionNb=2, it designates the second partition to be computed, and so on ...<br>
The order of units is implementation dependent.</p>
<p><i>Pre Conditions</i>: Uses ICapeNumericPartitioning::GetPartitionCount method in order to have the number  of partitions.</p>
<p><i>Post Conditions</i>: None.</p>
<dl>
  <dt> <b>Returns:</b>
  <dd>  A list of units.
</dl>
<dl>
  <dt> <b>Parameters:</b>
  <dd>  partitionNb: The rank of the partition.
</dl>
<dl>
  <dt> <b>Raises:</b>
  <dd> CapeBAD_INV_ORDER,  CapeBAD_PARAM, CapeUNKNOWN
</dl>
<dl>
  <dt> <b>See Also:</b>
  <dd> <a href=_ICapeNumericAnalysis.html#ICapeNumericAnalysis::Perform>ICapeNumericAnalysis::Perform</a> , <a href=_ICapeNumericPartitioning.html#ICapeNumericPartitioning::GetPartitionCount>GetPartitionCount</a> 
	  
</dl>

</dl>

<p>
<li><h3><a name=ICapeNumericPartitioning::SetExternalSystemId>SetExternalSystemId</a></h3>
<pre>
  void <b>SetExternalSystemId</b>(in <a href=_CapeLong.html#CapeLong>CapeLong</a> unitId)
    raises(<a href=_CapeBAD_PARAM.html#CapeBAD_PARAM>CapeBAD_PARAM</a>, <a href=_CapeUNKNOWN.html#CapeUNKNOWN>CapeUNKNOWN</a>);</pre><dl>
  <dd>  
<p>Sets the external system.</p>
<p><i>Pre Conditions</i>: None.</p>
<p><i>Post Conditions</i>: The unitId value will be used by CreateAndCompletePartitionGraph() method in 
order to characterise the FEED and PRODUCT streams.</p>
<dl>
  <dt> <b>Parameters:</b>
  <dd>  unitId: The unit identifier for the external system.
</dl>
<dl>
  <dt> <b>Raises:</b>
  <dd> CapeBAD_PARAM,  CapeUNKNOWN
</dl>
<dl>
  <dt> <b>See Also:</b>
  <dd> <a href=_ICapeNumericPartitioning.html#ICapeNumericPartitioning::CreateAndCompletePartitionGraph>CreateAndCompletePartitionGraph</a> 
	  
</dl>

</dl>

<p>
<hr>
<i>Generated by Sandia <a href=http://herzberg.ca.sandia.gov/idldoc/>idldoc</a> 1.0.</html>
